# 다익스트라 알고리즘
> 하나의 출발지에서 다른 모든 출발지까지 최단 경로 계산

## 개요
* 특정 노드에서 출발하여 다른 모든 노드로 이동
* 음의 간선이 없을 때 정상적으로 동작함
* 다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류됨
  * 매 상황에서 **가장 비용이 적은 노드**를 선택해서 임의의 과정을 반복하기 때문!

## 동작 과정
1. 출발 노드 설정(일반적으로 가장 작은 노드 선택)
2. 최단 거리 테이블을 초기화 (모든 거리가 INF)
3. 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신 (이때 경로도 표현하려면 별도의 소스코드 필요)
5. 3,4번의 과정을 반복

## 특징
* 그리디 알고리즘 : 방문하지 않은 가장 비용이 적은 노드를 선택
* 한 번 처리된 노드의 최단 거리는 고정

## 간단한 구현 방법(순차 탐색)
> 단계마다 방문하지 않은 노드 중, 최단 거리가 가장 짧은 노드를 선택하기 위해 매 단계마다 1차원 테이블의 모든 원소를 확인

### 성능
* O(V)번에 걸쳐서 노드를 매번 선형 탐색
* 일반적으로 코테의 최단 경로 문제에서 전체 노드의 개수가 5000개 이하라면 이렇게 문제 해결 가능. 하지만 그 이상은 어려움 -> 개선 필요! : 우선순위 큐

## +힙
우선순위 큐를 구현하기 위해 사용됨
파이썬에서는 기본적으로 최소힙 라이브러리를 제공함
```python
import heapq

#삽입
heapq.heaqpush(h, value)

#꺼내기
heapq.heappop(h)
```
## 개선된 구현 방법(우선순위 큐 이용)
> 최단 거리가 가장 짧은 노드를 선택하기 위해 힙 자료구조 이용

* 최단 거리 테이블을 갱신하고, 갱신된 노드 정보를 우선순위 큐에 삽입함.
* 우선순위가 높은 순서대로 노드를 처리함
* 큐에 명시된 거리 > 테이블에 기록된 거리 =>
    해당 노드는 이미 처리되었다고 판단하고 무시함. 
    우선순위 큐에 존재하는 다음 노드를 처리.

### 성능
* 시간복잡도 : O(ElogV)
- 노드를 하나씩 거내 검사하는 while문은 노드의 개수 V 이상 처리되지 않음
 → 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총횟수는 최대 간선의 개수 (E)만큼 연산이 수행될 수 있음
    
- 직관적으로 전체 과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 유사함.
- (왕복이상의 간선을 포함하지 않는 경우 시간복잡도):
    - O(ElogE) → O(ElogV**2) → O(2ElogV) → O(ElogV)
